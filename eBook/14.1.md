# 14.1 并发，并行和协程

## 14.1.1 什么是协程

一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。几乎所有'正式'的程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如Web服务器），或增加性能和吞吐量（例如，通过对不同的数据集并行执行代码）。一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有在同一个程序在某一个时间点在多个些处理内核或处理器上同时执行的任务才是真正的并行。

并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是。


公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作`竞态`）

！！不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。

解决之道在于同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。在Go的标准库`sync`中有一些工具用来在低级别的代码中实现加锁；我们在章节[9.3](9.3.md)中讨论过这个问题。不过过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核/多处理器编程："`thread-per-connection`"模型不够有效。

Go更倾向于其他的方式，在诸多比较合适的范式中，有个被称作`Communicating Sequential Processes（顺序通信处理）`(CSP, C. Hoare发明的)还有一个叫做`message passing-model（消息传递）`（已经运用在了其他语言中，比如Eralng）。

在Go中，应用程序并发处理的部分被称作`goroutines（协程）`，它可以进行更有效的并发运算。在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在Go运行时很好的完成了这个工作。

协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用`sync`包来实现（参见章节[9.3](9.3.md))，不过我们很不鼓励这样做：Go使用`channels`来同步协程（可以参见[14.2](14.2.md)等章节）



## 链接

- [目录](directory.md)
- 上一节：[性能调试：分析并优化 Go 程序](13.10.md)
- 下一节：[并发，并行和协程](14.1.md)
