# 14.6 协程和recover

一个用到`recover`的程序（参见章节13.3）停掉了服务器内部一个失败的协程而不影响其他协程的工作。
```go 
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)   // start the goroutine for that work
    }
}

func safelyDo(work *Work) {
    defer func {
        if err := recover(); err != nil {
            log.Printf("Work failed with %s in %v", err, work)
        }
    }()
    do(work)
}
```

## 链接

- [目录](directory.md)
- 上一节：[通道，超时和计时器](14.5.md)
- 下一节：[对比新旧模型：任务和工作](14.7.md)
